// Generated by CoffeeScript 2.3.2
(function() {
  var Config, MoonClass, PI, TIME_CONSTANT, TWO_PI, parse_moons, readyPromise;

  Config = require("./config.js");

  //TIME_CONSTANT = 6.378011090644188e-09
  TIME_CONSTANT = 6.461374608e-9; // Correcter value (thanks Szilard)

  //TIME_OFFSET = 27570
  PI = 3.141592653589;

  TWO_PI = 2 * PI;

  MoonClass = (function() {
    class MoonClass {
      constructor(id, name1, player1, faction1, income1, mass1, diameter1, semimajor1, ecc1, sign1) {
        this.calculate_trajectory = this.calculate_trajectory.bind(this);
        this.id = id;
        this.name = name1;
        this.player = player1;
        this.faction = faction1;
        this.income = income1;
        this.mass = mass1;
        this.diameter = diameter1;
        this.semimajor = semimajor1;
        this.ecc = ecc1;
        this.sign = sign1;
        // Derived from
        // https://www.wikiwand.com/en/Kepler%27s_laws_of_planetary_motion
        this.period = TIME_CONSTANT * this.semimajor ** 1.5;
        this.semiminor = this.semimajor * Math.sqrt(1 - this.ecc ** 2);
        this.positions = this.calculate_trajectory();
      }

      get_position_at_time(t) {
        " Return the position of the moon at time t ";
        var i, i0, i1, p0, p0x, p0y, p1, p1x, p1y, px, py, s;
        // Mod since we only save one period of positions
        t = ((t % this.period) + this.period) % this.period; // Disgusting trick to modulo negative numbers
        // Stolen from https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e

        // Convert time to index
        i = (t - Config["T0"]) / Config["DT"];
        // Interpolate between the indices we have
        i0 = Math.floor(i);
        i1 = Math.ceil(i);
        if (i0 >= this.positions.length) {
          i0 = this.positions.length - 1;
        }
        if (i1 >= this.positions.length) {
          i1 = this.positions.length - 1;
        }
        s = i - i0;
        p0 = this.positions[i0];
        p0x = p0[0];
        p0y = p0[1];
        p1 = this.positions[i1];
        p1x = p1[0];
        p1y = p1[1];
        px = p1x * s + p0x * (1 - s);
        py = p1y * s + p0y * (1 - s);
        return [px, py];
      }

      calculate_position_at_time(t) {
        " Return the position of the moon at time t (since alignment) ";
        var E, ITER_MAX, M, f, i, j, n, newton_step, r, ref, theta, x, x_new, y;
        n = TWO_PI / this.period; // mean motion
        M = n * t; // mean anomaly
        f = (x) => {
          return x - this.ecc * Math.sin(x) - M;
        };
        newton_step = (x) => {
          return (x - this.ecc * Math.sin(x) - M) / (2 * (1 - this.ecc * Math.cos(x)));
        };
        E = 0;
        x = M;
        ITER_MAX = 10;
        for (i = j = 0, ref = ITER_MAX; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          x_new = x - newton_step(x);
          E = x_new;
          if (f(x) < 0.001) { // desired accuracy achieved
            break;
          }
          x = x_new;
          if (i === ITER_MAX - 1) {
            console.log("Hit max iterations -- orbit may be slightly off course");
          }
        }
        theta = 2 * Math.atan(Math.sqrt(((1 + this.ecc) / (1 - this.ecc)) * Math.tan(E / 2) ** 2));
        if (E % TWO_PI > PI) {
          theta = TWO_PI - theta;
        }
        r = this.semimajor * (1 - this.ecc * Math.cos(E));
        theta *= this.sign; // Compensate for direction
        x = r * Math.cos(theta);
        y = r * Math.sin(theta);
        return [x, y];
      }

      calculate_trajectory() {
        var pos, poss, t;
        poss = [];
        t = Config["T0"];
        while (t <= Config["T1"] && t < Config["T0"] + this.period) {
          pos = this.calculate_position_at_time(t % this.period);
          poss.push(pos);
          t += Config["DT"];
        }
        return poss;
      }

      faction_color() {
        var d;
        d = {
          "BAIdu": "red",
          "NATO Inc.": "blue",
          "Godâ„¢": "green",
          "Daytime": "yellow",
          "Contested": "orange",
          "Muses": "brown"
        };
        if (d[this.faction] != null) {
          return d[this.faction];
        } else {
          return "lightgray";
        }
      }

    };

    MoonClass.data = "";

    return MoonClass;

  }).call(this);

  readyPromise = new Promise((resolve, reject) => {
    return $.ajax({
      url: "moons.csv",
      success: (data) => {
        MoonClass.data = data;
        return resolve("CSV downloaded");
      },
      dataType: "text"
    });
  });

  parse_moons = function() {
    var moons, parse_moon, row, rows;
    parse_moon = function(row) {
      var diameter, ecc, faction, id_, income, items, mass, moon, name, player, semimajor, sign;
      items = row.split(",");
      id_ = parseInt(items[0], 10);
      name = items[1];
      player = items[2];
      faction = items[3];
      income = parseInt(items[4], 10);
      mass = parseFloat(items[5]);
      diameter = parseFloat(items[6]);
      semimajor = parseFloat(items[7]);
      ecc = parseFloat(items[8]);
      sign = parseInt(items[10], 10);
      moon = new MoonClass(id_, name, player, faction, income, mass, diameter, semimajor, ecc, sign);
      return moon;
    };
    rows = MoonClass.data.split("\n").slice(1);
    moons = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = rows.length; j < len; j++) {
        row = rows[j];
        results.push(parse_moon(row));
      }
      return results;
    })();
    return moons;
  };

  module.exports = {
    parse_moons: parse_moons,
    readyPromise: readyPromise
  };

}).call(this);
